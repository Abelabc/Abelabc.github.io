{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"multi-thread-learning","date":"2023-11-30T07:33:55.331Z","updated":"2023-12-20T08:35:53.624Z","comments":true,"path":"api/articles/multi-thread-learning.json","keywords":null,"cover":null,"content":"<h1 id=\"multi-thread-learning\"><a href=\"#multi-thread-learning\" class=\"headerlink\" title=\"multi-thread-learning\"></a>multi-thread-learning</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><h2 id=\"v1\"><a href=\"#v1\" class=\"headerlink\" title=\"v1\"></a>v1</h2><p>学习多线程的基本用法，更新日常学习</p>\n<h3 id=\"11-30：\"><a href=\"#11-30：\" class=\"headerlink\" title=\"11&#x2F;30：\"></a>11&#x2F;30：</h3><p>创建子线程，协调子线程，thread库的学习。</p>\n<h3 id=\"12-18：\"><a href=\"#12-18：\" class=\"headerlink\" title=\"12&#x2F;18：\"></a>12&#x2F;18：</h3><p><strong>lock_guard(m,adopt_lock)<strong>第一个参数为adopt_lock标识时，表示构造函数中不再进行互斥量锁定，因此</strong>此时需要提前手动锁定</strong>。</p>\n<h4 id=\"unique-lock\"><a href=\"#unique-lock\" class=\"headerlink\" title=\"unique_lock\"></a><strong>unique_lock</strong></h4><p>(1)可以手动lock和unlock。（2）try_to_lock<strong>得保证锁处于unlock的状态</strong>,然后尝试现在能不能获得锁；尝试用mutx的lock()去锁定这个mutex，但如果没有锁定成功，会立即返回，不会阻塞在那里，并继续往下执行；(3)defer_lock始化了一个没有加锁的mutex;(4)owns_lock()检查锁成功与否</p>\n<p>(4)move(g2)所有权转移，让其他guard管理g2的锁。</p>\n<h3 id=\"12-19\"><a href=\"#12-19\" class=\"headerlink\" title=\"12&#x2F;19\"></a>12&#x2F;19</h3><h4 id=\"async与future\"><a href=\"#async与future\" class=\"headerlink\" title=\"async与future\"></a><em>async与future</em></h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">future&lt;double&gt; fu = async(t1, a, b);//fu占位</span><br></pre></td></tr></table></figure>\n\n<p>刚实例化的future是没有储存值的，但在调用std::future对象的get()成员函数时，主线程会被阻塞直到异步线程执行结束，并把返回结果传递给std::future</p>\n<h4 id=\"atmic\"><a href=\"#atmic\" class=\"headerlink\" title=\"atmic&lt;&gt;\"></a><em><strong>atmic&lt;&gt;</strong></em></h4><p>std::atomic&lt;&gt;对象提供了常见的原子操作（通过调用成员函数实现对数据的原子操作）： store是原子写操作，load是原子读操作。exchange是于两个数值进行交换的原子操作。 <strong>即使使用了std::atomic&lt;&gt;，也要注意执行的操作是否支持原子性</strong>，也就是说，你不要觉得用的是具有原子性的变量（准确说是对象）就可以为所欲为了，你对它进行的运算不支持原子性的话，也不能实现其原子效果。一般针对++，–，+&#x3D;，-&#x3D;，&amp;&#x3D;，|&#x3D;，^&#x3D;是支持的，这些原子操作是通过在std::atomic&lt;&gt;对象内部进行运算符重载实现的。</p>\n<h2 id=\"v2\"><a href=\"#v2\" class=\"headerlink\" title=\"v2\"></a>v2</h2><h3 id=\"Consumer-Producer\"><a href=\"#Consumer-Producer\" class=\"headerlink\" title=\"Consumer_Producer\"></a>Consumer_Producer</h3><p>实现了一个生产者消费者的多线程并发协作模型。</p>\n<h3 id=\"SafeDeque\"><a href=\"#SafeDeque\" class=\"headerlink\" title=\"SafeDeque\"></a>SafeDeque</h3><p>基于STL的dequeue容器, 来实现一个线程安全的双端队列。支持自定义等待时间跳出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const bool result = mCond.wait_for(lock, std::chrono::milliseconds(timeout), [this] &#123;return !mDequeue.empty();&#125;);</span><br></pre></td></tr></table></figure>\n\n\n\n<p>实现一个简单的线程池，并逐渐添加功能</p>\n","feature":true,"text":"multi-thread-learning目录v1学习多线程的基本用法，更新日常学习 11&#x2F;30：创建子线程，协调子线程，thread库的学习。 12...","permalink":"/post/multi-thread-learning","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#multi-thread-learning\"><span class=\"toc-text\">multi-thread-learning</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">目录</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#v1\"><span class=\"toc-text\">v1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-30%EF%BC%9A\"><span class=\"toc-text\">11&#x2F;30：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-18%EF%BC%9A\"><span class=\"toc-text\">12&#x2F;18：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#unique-lock\"><span class=\"toc-text\">unique_lock</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-19\"><span class=\"toc-text\">12&#x2F;19</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#async%E4%B8%8Efuture\"><span class=\"toc-text\">async与future</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#atmic\"><span class=\"toc-text\">atmic&lt;&gt;</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#v2\"><span class=\"toc-text\">v2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Consumer-Producer\"><span class=\"toc-text\">Consumer_Producer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SafeDeque\"><span class=\"toc-text\">SafeDeque</span></a></li></ol></li></ol></li></ol>","author":{"name":"Abelabc","slug":"blog-author","avatar":"","link":"https://github.com/Abelabc","description":"学习C++11新特性、Opengl、图形学、TingRender、UE5等学习记录","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"k-means_seg","date":"2023-12-02T09:32:27.140Z","updated":"2023-12-02T09:32:49.770Z","comments":true,"path":"api/articles/k-means_seg.json","keywords":null,"cover":[],"text":"kmeans算法进行图像分割 任务要求使用opencv的K-means函数对图像进行先分割，控制迭代目标停止，误差小于0.1。其次，由于k值的不确定性，利用sk...","permalink":"/post/k-means_seg","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Abelabc","slug":"blog-author","avatar":"","link":"https://github.com/Abelabc","description":"学习C++11新特性、Opengl、图形学、TingRender、UE5等学习记录","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"}}}},"feature":true},"next_post":{}}