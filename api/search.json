[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-12-28T06:49:34.316Z","categories_index":"","tags_index":"","author_index":"Abelabc"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"kmeans算法进行图像分割     \n任务要求使用opencv的K-means函数对图像进行先分割，控制迭代目标停止，误差小于0.1。其次，由于k值的不确定性，利用skimage.gabor滤波得到图像特征，为了量化分割图像和实际分割图像的似然性，通过gabor滤波得到列向量，然后对两幅图像的列向量进行余弦相似度计算，得到与实际分割图像最接近的分割图像;\n123456# 将不同分类的数据重新赋予另外一种颜色，实现分割图片data[best.ravel() == 0] = (0, 0, 0)  # 黑色data[best.ravel() == 1] = (255, 0, 0)  # 红色data[best.ravel() == 2] = (0, 0, 255)  # 蓝色data[best.ravel() == 3] = (0, 255, 0)  # 绿色data[best.ravel() == 4] = (255, 255, 255)  # 白色\n\n\n\n\n\n\n\n\n\n\n图为：K&#x3D;2\n\n\n\n\n\n\n\n\n\n\n图为：K&#x3D;3\n\n\n\n\n\n\n\n\n\n\n图为：K&#x3D;4\n\n\n\n\n\n\n\n\n\n\n图为：K&#x3D;5\n通过定义 gaborcls 函数计算原始 mapB.bmp 的特征值123456789101112131415def gaborcls(filename):    img = cv2.imread(filename)  # 读图像    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  # 转灰度    frequency = 0.6    # gabor变换    real, imag = filters.gabor(img_gray, frequency=0.6, theta=60, n_stds=5)    # 取模    img_mod = np.sqrt(real.astype(float) ** 2 + imag.astype(float) ** 2)    # 图像缩放（下采样）    newimg = cv2.resize(img_mod, (0, 0), fx=1 / 4, fy=1 / 4, interpolation=cv2.INTER_AREA)    tempfea = newimg.flatten()  # 矩阵展平    tmean = np.mean(tempfea)  # 求均值    tstd = np.std(tempfea)  # 求方差    newfea = (tempfea - tmean) / tstd  # 数值归一化    return newfea\nThe most similar image obtained in the end is 3.jpg：\n\n\n\n\n\n\n\n\n\n图为：K&#x3D;3\n\n\n\n\n\n\n\n\n\n\n图为：分割图\n","slug":"k-means_seg","date":"2023-12-02T09:32:27.140Z","categories_index":"","tags_index":"","author_index":"Abelabc"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"multi-thread-learning目录v1学习多线程的基本用法，更新日常学习\n11&#x2F;30：创建子线程，协调子线程，thread库的学习。\n12&#x2F;18：lock_guard(m,adopt_lock)第一个参数为adopt_lock标识时，表示构造函数中不再进行互斥量锁定，因此此时需要提前手动锁定。\nunique_lock(1)可以手动lock和unlock。（2）try_to_lock得保证锁处于unlock的状态,然后尝试现在能不能获得锁；尝试用mutx的lock()去锁定这个mutex，但如果没有锁定成功，会立即返回，不会阻塞在那里，并继续往下执行；(3)defer_lock始化了一个没有加锁的mutex;(4)owns_lock()检查锁成功与否\n(4)move(g2)所有权转移，让其他guard管理g2的锁。\n12&#x2F;19async与future1future&lt;double&gt; fu = async(t1, a, b);//fu占位\n\n刚实例化的future是没有储存值的，但在调用std::future对象的get()成员函数时，主线程会被阻塞直到异步线程执行结束，并把返回结果传递给std::future\natmic&lt;&gt;std::atomic&lt;&gt;对象提供了常见的原子操作（通过调用成员函数实现对数据的原子操作）： store是原子写操作，load是原子读操作。exchange是于两个数值进行交换的原子操作。 即使使用了std::atomic&lt;&gt;，也要注意执行的操作是否支持原子性，也就是说，你不要觉得用的是具有原子性的变量（准确说是对象）就可以为所欲为了，你对它进行的运算不支持原子性的话，也不能实现其原子效果。一般针对++，–，+&#x3D;，-&#x3D;，&amp;&#x3D;，|&#x3D;，^&#x3D;是支持的，这些原子操作是通过在std::atomic&lt;&gt;对象内部进行运算符重载实现的。\nv2Consumer_Producer实现了一个生产者消费者的多线程并发协作模型。\nSafeDeque基于STL的dequeue容器, 来实现一个线程安全的双端队列。支持自定义等待时间跳出。\n1const bool result = mCond.wait_for(lock, std::chrono::milliseconds(timeout), [this] &#123;return !mDequeue.empty();&#125;);\n\n\n\n实现一个简单的线程池，并逐渐添加功能\n","slug":"multi-thread-learning","date":"2023-11-30T07:33:55.331Z","categories_index":"","tags_index":"","author_index":"Abelabc"}]